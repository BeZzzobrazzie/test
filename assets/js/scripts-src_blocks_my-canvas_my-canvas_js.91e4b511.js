/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkprtf_hotel"] = self["webpackChunkprtf_hotel"] || []).push([["scripts-src_blocks_my-canvas_my-canvas_js"],{

/***/ "./src/blocks/my-canvas/my-canvas.js":
/*!*******************************************!*\
  !*** ./src/blocks/my-canvas/my-canvas.js ***!
  \*******************************************/
/***/ (() => {

eval("\n\nclass Main {\n  constructor() {\n    this.canvas = document.querySelector('.my-canvas');\n    this.cHeight = this.canvas.getAttribute('height');\n    this.cWidth = this.canvas.getAttribute('width');\n    \n    this.ctx = this.canvas.getContext('2d');\n    this.step = 20;\n\n    this.objects = {creatures: {},\n                    apples: {},\n                    };\n    this.cells = {};\n    this.arrCells = [];\n\n    this.timerId;\n    this.timerStatus = false;\n    this.delay = 1000;\n\n    this.createField();\n    this.drawField();\n\n    for (let i = 0; i < 2; i++) {\n      new Creature(getRandomInt(0, this.cWidth / this.step), getRandomInt(0, this.cHeight / this.step), this.step, this.cWidth, this.cHeight, this.ctx, this);\n    };\n    for (let i = 0; i < 1; i++) {\n      new Apple(getRandomInt(0, this.cWidth / this.step), getRandomInt(0, this.cHeight / this.step), this.step, this.cWidth, this.cHeight, this.ctx, this);\n    };\n\n  }\n\n  createField() {\n    for (let y = 1, a = 1; y <= this.cHeight; y = y + this.step, a++) {\n      for (let x = 1, b = 1; x <= this.cWidth; x = x + this.step, b++) {\n        //console.log('a: ' + a + ' b: ' + b + ' cell: ' + ((a - 1) * (this.cWidth / this.step) + b));\n        let addressCell = (a - 1) * (this.cWidth / this.step) + b;\n        this.cells[addressCell] = {x: x, y: y, size: 18, obj: null};\n        this.arrCells[addressCell - 1] = addressCell;\n      }\n    }\n\n\n\n    for (let y = 1, a = 1; y <= this.cHeight; y = y + this.step, a++) {\n      for (let x = 1, b = 1; x <= this.cWidth; x = x + this.step, b++) {\n        let addressCell = (a - 1) * (this.cWidth / this.step) + b;\n\n        if (addressCell - this.cWidth / this.step <= 0) {\n          this.cells[addressCell].up = null;\n        }\n        else {\n          this.cells[addressCell].up = this.cells[addressCell - this.cWidth / this.step];\n        }\n\n        if (addressCell + 1 > this.cWidth / this.step * a) {\n          this.cells[addressCell].right = null;\n        }\n        else {\n          this.cells[addressCell].right = this.cells[addressCell + 1];\n        }\n\n        if (addressCell + this.cWidth / this.step > this.cWidth / this.step * this.cHeight / this.step) {\n          this.cells[addressCell].bottom = null;\n        }\n        else {\n          this.cells[addressCell].bottom = this.cells[addressCell + this.cWidth / this.step];\n        }\n\n        if (addressCell - 1 <= this.cWidth / this.step * a - this.cWidth / this.step) {\n          this.cells[addressCell].left = null;\n        }\n        else {\n          this.cells[addressCell].left = this.cells[addressCell - 1];\n        }\n\n\n        //console.log('addressCell: ' + addressCell + ' a: ' + a + ' b: ' + b);\n      }\n    }\n\n    console.log(this.cells);\n  }\n\n  drawField() {\n    for (let i = this.step; i <= this.cWidth - this.step; i = i + this.step) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(i, 0);\n      this.ctx.lineTo(i, this.cHeight);\n      this.ctx.stroke();\n      this.ctx.closePath();\n    }\n    for (let i = this.step; i <= this.cHeight - this.step; i = i + this.step) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, i);\n      this.ctx.lineTo(this.cWidth, i);\n      this.ctx.stroke();\n      this.ctx.closePath();\n    }  \n  }\n\n\n  timer(delay) {\n    let thisObj = this;\n    thisObj.timerId = setTimeout(function tick() {\n      //console.log(thisObj.objects);\n      //console.log(thisObj.cells);\n      for (let key in thisObj.objects.creatures) {\n\n        //thisObj.objects.creatures[key].go();\n        //thisObj.objects.creatures[key].sense();\n        thisObj.objects.creatures[key].decide();\n\n      }\n      thisObj.timerId = setTimeout(tick, delay);\n    }, delay, thisObj);\n  }\n\n  startTimer(delay) {\n    if (!this.timerStatus) {\n      this.timerStatus = true;\n      this.timer(delay);\n    }\n  }\n  \n  stopTimer() {\n    if (this.timerStatus) {\n      this.timerStatus = false;\n      clearTimeout(this.timerId);\n    }\n  }\n  nextStep() {\n    this.startTimer(0);\n    setTimeout(() => this.stopTimer(), 0);\n  }\n\n\n\n}\n\n\nclass Entity {\n  constructor(x, y, step, cWidth, cHeight, ctx, main) {\n    this.step = step;\n    this.currentCell;\n    this.cWidth = cWidth;\n    this.cHeight = cHeight;\n    this.ctx = ctx;\n    this.main = main;\n    this.name;\n    this.type;\n  }\n\n  create(ctx, color, type) {\n    let randomCell = getRandomCell(this.main.arrCells);\n    console.log(randomCell);\n\n    this.currentCell = this.main.cells[randomCell];\n    this.currentCell.obj = this;\n\n    this.name = getId(this.main.objects[type]);\n    this.main.objects[type][this.name] = this;\n\n    \n    ctx.fillStyle = color;\n    ctx.fillRect(this.currentCell.x, this.currentCell.y, this.currentCell.size, this.currentCell.size);\n\n    console.log(this);\n  }\n\n  die(ctx) {\n    if (this.name in this.main.objects[type]) {\n      ctx.fillStyle = 'white';\n      ctx.fillRect(this.currentPos.x, this.currentPos.y, 18, 18);\n      delete this.main.objects[type][this.name];\n    }\n  }\n\n}\n\nclass Apple extends Entity {\n  constructor(x, y, step, cWidth, cHeight, ctx, main) {\n    super(x, y, step, cWidth, cHeight, ctx, main);\n    this.type = 'apples';\n    this.create(ctx, 'orange', this.type);\n  }\n\n}\n\nclass Creature extends Entity {\n  constructor(x, y, step, cWidth, cHeight, ctx, main) {\n    super(x, y, step, cWidth, cHeight, ctx, main);\n    this.type = 'creatures';\n    this.create(ctx, 'blue', this.type);\n  }\n\n  exist() {\n    let direction = getRandomInt(1, 5);\n    //this.sense();\n    //this.decide();\n\n  }\n\n  sense() {\n    function senseDir(direction, parrent) {\n      if (parrent.currentCell[direction] !== null && parrent.currentCell[direction].obj !== null) {\n        return parrent.currentCell[direction].obj.type;\n      }\n      else {\n        return null;\n      }\n    }\n    let up;\n    let right;\n    let bottom;\n    let left;\n    \n    up = senseDir('up', this);\n    right = senseDir('right', this);\n    bottom = senseDir('bottom', this);\n    left = senseDir('left', this);\n\n\n    //console.log({up: up, right: right, bottom: bottom, left: left});\n    return {up: up, right: right, bottom: bottom, left: left};\n  }\n\n  decide() {\n    console.log(this);\n    let view = this.sense();\n    for (let key in view) {\n      if (view[key] == 'apples') {\n        console.log('direction: ' + key + ' value: ' + view[key]);\n        this.go(key);\n        return;\n      }\n    }\n    this.go(convertToDirection(getRandomInt(1, 5)));\n\n  }\n\n  eat(direction) {\n    if (direction == 1 && this.currentCell.up.obj.type == 'apples') {\n\n    }\n    if (direction == 2 && this.currentCell.right.obj.type == 'apples') {\n\n    }\n    if (direction == 3 && this.currentCell.bottom.obj.type == 'apples') {\n\n    }\n    if (direction == 4 && this.currentCell.left.obj.type == 'apples') {\n\n    }\n  }\n\n  sleep() {\n\n  }\n\n  go(direction) {\n    //let direction = getRandomInt(1, 5);\n    //console.log(direction);\n\n\n    if (direction == 'up' && this.currentCell.y >= this.step && this.currentCell.up.obj !== 'creatures') { // up\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillRect(this.currentCell.x, this.currentCell.y, this.currentCell.size, this.currentCell.size);\n      this.currentCell.obj = null;\n\n      this.ctx.fillStyle = 'blue';\n      this.ctx.fillRect(this.currentCell.x, this.currentCell.y - this.step, this.currentCell.size, this.currentCell.size);\n      this.currentCell = this.currentCell.up;\n      this.currentCell.obj = this;\n\n      //console.log('up');\n    }\n    if (direction == 'right' && this.currentCell.x <= this.cWidth - this.step && this.currentCell.right.obj !== 'creatures') { // right\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillRect(this.currentCell.x, this.currentCell.y, this.currentCell.size, this.currentCell.size);\n      this.currentCell.obj = null;\n\n      this.ctx.fillStyle = 'blue';\n      this.ctx.fillRect(this.currentCell.x + this.step, this.currentCell.y, this.currentCell.size, this.currentCell.size);\n      this.currentCell = this.currentCell.right;\n      this.currentCell.obj = this;\n\n      //console.log('right');\n    }\n    if (direction == 'bottom' && this.currentCell.y <= this.cHeight - this.step && this.currentCell.bottom.obj !== 'creatures') { //bottom\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillRect(this.currentCell.x, this.currentCell.y, this.currentCell.size, this.currentCell.size);\n      this.currentCell.obj = null;\n\n      this.ctx.fillStyle = 'blue';\n      this.ctx.fillRect(this.currentCell.x, this.currentCell.y + this.step, this.currentCell.size, this.currentCell.size);\n      this.currentCell = this.currentCell.bottom;\n      this.currentCell.obj = this;\n\n      //console.log('bottom');\n    }\n    if (direction == 'left' && this.currentCell.x >= this.step && this.currentCell.left.obj !== 'creatures') { // left\n      this.ctx.fillStyle = 'white';\n      this.ctx.fillRect(this.currentCell.x, this.currentCell.y, this.currentCell.size, this.currentCell.size);\n      this.currentCell.obj = null;\n\n      this.ctx.fillStyle = 'blue';\n      this.ctx.fillRect(this.currentCell.x - this.step, this.currentCell.y, this.currentCell.size, this.currentCell.size);\n      this.currentCell = this.currentCell.left;\n      this.currentCell.obj = this;\n\n      //console.log('left');\n    }\n  }\n}\n\nfunction getId(collection) {\n  while (true) {\n    let key = getRandomInt(0, 10000);\n    if (!(key in collection)) {\n      return key;\n    }\n  }\n}\n\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min; //Максимум не включается, минимум включается\n}\n\nfunction convertToDirection(number) {\n  switch(number) {\n    case 1:\n      return 'up';\n    case 2:\n      return 'right';\n    case 3:\n      return 'bottom';\n    case 4:\n      return 'left';\n    default:\n      console.log('что то пошло не так');\n  } \n}\n\nfunction draw() {\n  let canvas = document.querySelector('.my-canvas');\n  let cHeight = canvas.getAttribute('height');\n  let cWidth = canvas.getAttribute('width');\n  \n  let ctx = canvas.getContext('2d');\n  let step = 20;\n  let currentPos = {x: 21, y: 21};\n\n  for (let i = step; i <= cWidth - step; i = i + step) {\n    ctx.beginPath();\n    ctx.moveTo(i, 0);\n    ctx.lineTo(i, cHeight);\n    ctx.stroke();\n    ctx.closePath();\n  }\n  for (let i = step; i <= cHeight - step; i = i + step) {\n    ctx.beginPath();\n    ctx.moveTo(0, i);\n    ctx.lineTo(cWidth, i);\n    ctx.stroke();\n    ctx.closePath();\n  }  \n  ctx.fillStyle = 'green';\n  ctx.fillRect(21,21,18,18);\n\n  goTo(ctx, currentPos, step, cWidth, cHeight);\n\n  //let i = new Creature(10, 5, step, cWidth, cHeight, ctx);\n  //i.create(ctx);\n  for (let a = 0; a < 3; a++) {\n    let i = new Creature(getRandomInt(0, cWidth / step), getRandomInt(0, cHeight / step), step, cWidth, cHeight, ctx);\n  }\n\n  let timerId = setTimeout(function tick() {\n    console.log('hi');\n    timerId = setTimeout(tick, 1000);\n  }, 1000);\n\n\n}\n\nfunction goTo(ctx, currentPos, step, cWidth, cHeight) {\n  document.addEventListener('keydown', function(event) {\n    if (event.code == 'KeyD' && currentPos.x <= cWidth - step) {\n      ctx.fillStyle = 'white';\n      ctx.fillRect(currentPos.x, currentPos.y, 18, 18);\n\n      ctx.fillStyle = 'green';\n      ctx.fillRect(currentPos.x + step, currentPos.y, 18, 18);\n      currentPos.x += step;\n    }\n    if (event.code == 'KeyA' && currentPos.x >= step) {\n      ctx.fillStyle = 'white';\n      ctx.fillRect(currentPos.x, currentPos.y, 18, 18);\n\n      ctx.fillStyle = 'green';\n      ctx.fillRect(currentPos.x - step, currentPos.y, 18, 18);\n      currentPos.x -= step;\n    }\n    if (event.code == 'KeyW' && currentPos.y >= step) {\n      ctx.fillStyle = 'white';\n      ctx.fillRect(currentPos.x, currentPos.y, 18, 18);\n\n      ctx.fillStyle = 'green';\n      ctx.fillRect(currentPos.x, currentPos.y - step, 18, 18);\n      currentPos.y -= step;\n    }\n    if (event.code == 'KeyS' && currentPos.y <= cHeight - step) {\n      ctx.fillStyle = 'white';\n      ctx.fillRect(currentPos.x, currentPos.y, 18, 18);\n\n      ctx.fillStyle = 'green';\n      ctx.fillRect(currentPos.x, currentPos.y + step, 18, 18);\n      currentPos.y += step;\n    }\n  })\n}\n\nfunction getRandomCell(arr) {\n  //console.log(arr);\n  let randomCell;\n  randomCell = getRandomInt(0, arr.length);\n  let value = arr[randomCell];\n  arr.splice(randomCell, 1);\n  \n  return value;\n}\n\nclass ControlPanel {\n  constructor(main) {\n    this.main = main;\n\n    this.btnPreviousStep = document.querySelector('.btn-previous-step');\n    this.btnPlayPause = document.querySelector('.btn-play-pause');\n    this.btnNextStep = document.querySelector('.btn-next-step');\n    this.btnReset = document.querySelector('.btn-reset');\n    this.rangeDelay = document.querySelector('.range-delay');\n\n    this.btnPreviousStep.addEventListener('click', this);\n    this.btnPlayPause.addEventListener('click', this);\n    this.btnNextStep.addEventListener('click', this);\n    this.btnReset.addEventListener('click', this);\n    this.rangeDelay.addEventListener('change', this);\n  }\n\n  handleEvent(event) {\n    //console.log(event);\n    if (event.target.classList.contains('btn-previous-step')) {\n      console.log(event.target);\n    }\n    else if (event.target.classList.contains('btn-play-pause')) {\n      if (!this.main.timerStatus) {\n        this.main.startTimer(this.main.delay);\n      }\n      else if (this.main.timerStatus) {\n        this.main.stopTimer();\n      }\n    }\n    else if (event.target.classList.contains('btn-next-step')) {\n      //console.log(event.target);\n      this.main.nextStep();\n    }\n    else if (event.target.classList.contains('btn-reset')) {\n      console.log(event.target);\n    }\n    else if (event.target.classList.contains('range-delay')) {\n      //console.log(this.rangeDelay.value);\n      this.main.delay = this.rangeDelay.value;\n      this.main.stopTimer();\n      this.main.startTimer(this.main.delay);\n\n    }\n  }\n\n\n}\n\n\n\nlet body = document.querySelector('body');\nbody.onload = function() {\n  let main = new Main();\n  let controlPanel = new ControlPanel(main);\n}\n//body.onload = new Main();\n//body.onload = new ControlPanel();\n\n//# sourceURL=webpack://prtf_hotel/./src/blocks/my-canvas/my-canvas.js?");

/***/ })

}]);